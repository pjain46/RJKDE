# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Sample from a Gaussian Mixture Model
#'
#' Generates random samples from a mixture of normal distributions with specified means
#' and a common standard deviation.
#'
#' @param mu: A numeric vector of component means (e.g., c(-1, 0, 1) for a 3-component mixture).
#' @param sigma: The common standard deviation for all mixture components (must be > 0).
#' @return A numeric vector of length 1 containing a single random sample from the mixture distribution.
#'
#' @details
#' This function implements the following steps:
#' \enumerate{
#'   \item Randomly selects one component from the mixture with equal probability
#'   \item Generates a sample from N($\mu_i$, $\sigma^2$) where $\mu_i$ is the selected component's mean
#' }
#'
#' @examples
#' # Sample from a 2-component mixture
#' means <- c(-1, 1)  # Means at -1 and 1
#' rnormmix_rcpp(means, 0.5)  # Common SD = 0.5
#'
#' # Sample from a 3-component mixture
#' rnormmix_rcpp(c(-2, 0, 2), 1.0)
#'
#' @seealso \code{\link{rnorm}} for sampling from single normal distribution
#' @export
#'
rnormmix_rcpp <- function(mu, sigma) {
    .Call(`_RJKDE_rnormmix_rcpp`, mu, sigma)
}

#' Compute Log-Density of a Gaussian Mixture Model
#'
#' Calculates the log-probability density at data point `x` for a mixture of normal distributions
#' with given means, standard deviations, and uniform weights.
#'
#' @param mu: A numeric vector of component means of length k.
#' @param sigma: A numeric vector of standard deviations for each component of length k.
#' @param w: A numeric vector of component weights (in this case it is a vector of length k of ones).
#' @param x: Scalar value where density is evaluated.
#'
#' @return The log-density value at `x`.
#'
#' @details
#' The density is computed as:
#' \deqn{\log\left(\sum_{i=1}^k \frac{w_i}{k} \cdot \phi(x|\mu_i,\sigma_i)\right)}
#' where \eqn{\phi(x|\mu_i,\sigma_i)} is the normal PDF with mean \eqn{\mu_i} and standard deviation \eqn{\sigma_i}.
#'
#' @note
#' Weights are automatically normalized by the number of components (k), so the input weights
#' need not sum to 1. For standard weighted mixtures, pass pre-normalized weights.
#'
#' @examples
#' # Evaluate at x=0 for 2-component mixture
#' KDE_density_rcpp(mu = c(-1, 1),
#'                  sigma = c(0.5, 0.5),
#'                  w = c(1, 1),  # Weights automatically normalized
#'                  x = 0)
#'
#' # Compare with single normal distribution
#' KDE_density_rcpp(mu = 0, sigma = 1, w = 1, x = 0)  # log(dnorm(0,0,1))
#'
#' @seealso \code{\link{dnorm}} for single-component density
#' @export
KDE_density_rcpp <- function(mu, sigma, w, x) {
    .Call(`_RJKDE_KDE_density_rcpp`, mu, sigma, w, x)
}

#' Run Reversible Jump Markov Chain Monte Carlo for Gaussian Mixture Models
#'
#' Performs Bayesian estimation of Gaussian mixture models with variable number of components
#' using Reversible Jump MCMC (RJMCMC).
#'
#' @param y: A numeric vector of observed data points.
#' @param ygrid: A numeric vector of grid points for density estimation (eg., ygrid <- seq(min(y),max(y),length.out = 500)).
#' @param drop_add_prob Numeric vector of probabilities for (drop, keep, add) moves
#'        (default: c(0.45, 0.1, 0.45)).
#' @param sig_a: Shape parameter for Beta prior on bandwidths (default: 5).
#' @param sig_b: Scale parameter for Beta prior on bandwidths (default: 5).
#' @param mu_step_size: Step size for mean proposals (default: 0.1).
#' @param k: Initial number of mixture components (default: 20).
#' @param bw: Bandwidth parameter (default: 0.2).
#' @param mc: Number of MCMC iterations (default: 5000).
#' @param mu_h: Hyperparameter for mean adjustment (default: 0.0).
#' @param sig_h: Hyperparameter for bandwidth adjustment (default: 1.0).
#'
#' @return A List object containing:
#' \describe{
#'   \item{fsamps}{Matrix of density samples (columns) evaluated at ygrid points (rows)}
#'   \item{fsamps_adj}{Adjusted density samples}
#'   \item{ksamps}{Vector of component counts across iterations}
#'   \item{ygrid}{Input grid points (for reference)}
#' }
#'
#' @details
#' The algorithm implements:
#' \enumerate{
#'   \item Component add/drop component moves via RJMCMC
#'   \item Adaptive proposals for means and bandwidths
#'   \item Posterior density estimation on provided grid
#' }
#'
#' @examples
#' \dontrun{
#' # Generate sample data
#' set.seed(123)
#' y <- c(rnorm(200, -2, 1), rnorm(300, 2, 1))
#'
#' # Create evaluation grid
#' ygrid <- seq(-5, 5, length.out = 100)
#'
#' # Run MCMC
#' results <- rj_mcmc_rcpp(y, ygrid, mc = 1000)
#'
#' # Plot posterior mean density
#' plot(ygrid, rowMeans(results$fsamps), type = "l",
#'      main = "Posterior Density Estimate")
#' }
#'
#' @seealso \code{\link{KDE_density_rcpp}} for the density calculation function
#' @export
rj_mcmc_rcpp <- function(y, ygrid, drop_add_prob = as.numeric( c(0.45,0.1,0.45)), sig_a = 5, sig_b = 5, mu_step_size = 0.1, k = 20L, bw = 0.2, mc = 5000L, mu_h = 0.0, sig_h = 1.0) {
    .Call(`_RJKDE_rj_mcmc_rcpp`, y, ygrid, drop_add_prob, sig_a, sig_b, mu_step_size, k, bw, mc, mu_h, sig_h)
}

